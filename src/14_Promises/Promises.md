# Promises
## 1. Что такое promise, then, catch - основы

**`Promise`** - объект (обещание), который может находиться в одном из 3-х состояний: `pending`(ожидание), `resolved/fulfilled`(выполнен успешно), `rejected`(выполнен с ошибкой). При этом, если промис перешел в состояние `resolved` или `rejected`, то изменить его он уже не сможет. 

Объект `promise`, как правило, возвращает какая-то функция вместо конкретных данных, ввуду того, что функция не может вернуть эти данные здесь и сейчас (запрос на сервер, в базу данных и т.п. выполняются асинхронно).

### Интерфейс объекта `promise`:
 1. Свойств нет;
 2.  **Метод `then`** - для подписки на событие `resolve` промиса (когда `promise` будет за-`resolve`-лен). В `then` передается коллбэк. Этот коллбэк выполняется, когда `promise` за-`resolve`-тся. Как правило, в этот коллбэк приходят данные, которые функция обещает достать.
 3.  **Метод `catch`** - для подписки на событие `reject` промиса (`promise` никогда не выполнится). Когда `promise` `reject`-тся, это воспринимается браузером как ошибка, но эта ошибка в отличие от остальных не ломает всё приложения. Т.е. в `then` при таком раскладе мы никогда не попадем. В `catch` также, как и в `then` передается коллбэк, в который, как правило, приходит какая-то ошибка. Как правило, для одного промиса используется и `then` и `catch` в виде последовательной цепочки, чтобы предусматреть все ситуации. 
 4. **Метод `finally`** - метод, в котором выполняется функционал, независимо от того, promise за-`resolve`-лся или за-`reject`-ился. В `finally` также передается коллбэк, но в этот коллбэк уже не приходят никакие данные. Это просто кусок кода, который выполняется, когда `promise` за-`resolve`-ился или за-`reject`-ился.
 
 ## 2. Схематично про state\status промиса: pending\fullfilled\rejected
![Promise1](./assets/promiseInit@2x.png)
![Promise2](./assets/promise-resolve-reject.svg)

**Promise** (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.

На promise можно навешивать колбэки двух типов:

- `onFulfilled` – срабатывают, когда promise в состоянии «выполнен успешно».
- `onRejected` – срабатывают, когда promise в состоянии «выполнен с ошибкой».
Способ использования, в общих чертах, такой:

1. Код, которому надо сделать что-то асинхронно, создаёт объект `promise` и возвращает его.
2. Внешний код, получив `promise`, навешивает на него обработчики.
3. По завершении процесса асинхронный код переводит `promise` в состояние `fulfilled` (с результатом) или `rejected` (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

## 3. Promise.all / Promise.allSettled
Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.

Например, параллельно загрузить несколько файлов и обработать результат, когда он готов.

Для этого как раз и пригодится статический метод класса `Promise` - `Promise.all( )`. 

Метод `Promise.all` принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.

Новый промис завершится только тогда, когда завершится весь переданный список промисов, и **его результатом будет массив их результатов**.

Порядок элементов массива реультатов в точности соответствует порядку исходных промисов. Даже если первый промис будет выполняться дольше всех, его результат всё равно будет первым в массиве.

  
> ⚠ Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.

Метод `Promise.allSettled` всегда ждёт завершения всех промисов. В массиве результатов будет:

    `{status:"fulfilled", value:результат}` для успешных завершений,
    
    `{status:"rejected", reason:ошибка}` для ошибок.
    
   Например, мы хотели бы загрузить информацию о множестве пользователей. Даже если в каком-то запросе ошибка, нас всё равно интересуют остальные.
   
## 4. Статические методы Promise.resolve | Promise.reject

**`Promise.resolve(value)`** создаёт успешно выполненный промис с результатом value.
То же самое, что:

    let promise = new Promise(resolve => resolve(value));

Этот метод используют для совместимости: когда ожидается, что функция возвратит именно промис.

**`Promise.reject(error)`** создаёт промис, завершённый с ошибкой error.
То же самое, что:

    let promise = new Promise((resolve, reject) => reject(error));
    
## 5. Цепочка then | chaning

1. Каждый вызов `then` возвращает новый `promise`. 
2. Этот `promise` за-`resolve`-ится тогда, когда за-`resolve`-ится `promise`, для которого был вызван метод `then`, и выполнится коллбэк, переданный в метод `then`. 
3. И соответственно этот новый `promise` за-`resolve`-ится значением, которое вернет этот метод `then`.
4. Соответственно, чтобы последующий `promise` цепочки за-`resolve`-ился каким-то значением, коллбэк, переданный в `then` для предыдущего `promise`, должен вернуть это значение. 
5. Если этот коллбэк ничего явно не возвращет (нет `return`), то `promise` за-`resolve`-ится значением `undefined`.
6. Если очередной коллбэк, переданный в `then`, возвращает не примитив, не объект, а `promise`, то в коллбэк последующего `then` придет не сам этот `promise`, а значение, которым этот `promise` за-`resolve`-ится.

## 6. async\await

Мы используем `then` для того, чтобы дождаться, когда `promise` за-`resolve`-ится. И при этом в `then` мы испольуем коллбэк, чтобы получить результат, которым за-`resolve`-ится `promise`, для которого этот `then` был вызван. То есть по факту мы использум `then` и коллбэк в нем, чтобы получить какие-то данные.

Существует специальный синтаксис для работы с промисами, который называется «async/await». 

У слова `async` один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически. Так что ключевое слово `async` перед функцией гарантирует, что эта функция в любом случае вернёт промис. 

Но это ещё не всё. Есть другое ключевое слово – `await`, которое можно использовать только внутри async-функций. Ключевое слово `await` заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от `await` не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем `promise.then.`

> ⚠ `await` нельзя использовать в обычных функциях
Если мы попробуем использовать await внутри функции, объявленной без async, получим синтаксическую ошибку.
>
> ⚠ `await` нельзя использовать на верхнем уровне вложенности
 Программисты, узнав об `await`, часто пытаются использовать эту возможность на верхнем уровне вложенности (вне тела функции). Но из-за того, что `await` работает только внутри async–функций, так сделать не получится. 

## 7. Зачем создавать свои промисы / промисификация, new Promise()

Если мы заранее знаем, что наша функция в будущем усложнится асинхронными операциями (запрос на сервер, например), то нужно сделать промичификацию, то есть вернуть промис. И далее с результатом этой функции уже можно будет работать через `then` или `async` `await`

`Промисификация` – это длинное слово для простого преобразования. Мы берём функцию, которая принимает колбэк и меняем её, чтобы она вместо этого возвращала промис.

Такие преобразования часто необходимы в реальной жизни, так как многие функции и библиотеки основаны на колбэках, а использование промисов более удобно, поэтому есть смысл «промисифицировать» их.

Один из способов создания промиса - вызов функции-конструктора (класса):

    const promise = new Promise()
    
При этом появляется необходимость описать логику промиса. Логика в промис помещается через коллбэк функцию. При создании промиса этe функция запускает сразу движок JS и при этом передает в нее две другие функции: `resolve()` и `reject()`. И тогда, если мы в теле этой функции вызовем `resolve()` и передадим в нее какое-то значение, то промис за-`resolve`-ится этим значением. Аналогично в `reject`:
    
    function getNumber() {
        const promise = new Promise((resolve, reject) => {
            resolve(Math.random())
            })
            return promise
    }
При этом в этом коллбэке мы можем создавать логику какой угодно сложности, в том числе и иммитацию асинхронных запросов на сервер через setTimeout(). Один из таких примеров - временная работа с `localStorage` до перехода на работу с сервером.

